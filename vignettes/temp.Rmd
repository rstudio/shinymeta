---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "#>")
options(shiny.suppressMissingContextError=TRUE)
library(shiny)
library(shinymeta)
library(sourcetools)
library(dplyr)
library(styler)
deparse_flatten <- function(expr, width.cutoff = 500L) {
  if (is.call(expr) && length(expr) > 1 && identical(expr[[1]], quote(`{`))) {
    unlist(lapply(expr[-1], deparse_flatten))
  } else {
    deparse(expr, width.cutoff = width.cutoff)
  }
}
# Neither deparse() nor styler will go out of their way to break on %>%, and
# deparse will break on other random operators instead. This function inserts
# newlines after %>%, and replaces newlines that follow operators or commas with
# a single space. The resulting code string will not contain indentation, and
# must be processed further to be considered readable.
rebreak <- function(str) {
  if (typeof(str) == "language" || typeof(str) == "symbol") {
    str <- deparse_flatten(str)
  }
  str <- paste(str, collapse = "\n")
  tokens <- tokenize_string(str)
  tokens$value <- paste0(tokens$value, ifelse(tokens$type == "operator" & tokens$value == "%>%", "\n", ""))
  operator_newline <- grepl("\n", tokens$value) & tokens$type == "whitespace" & c(FALSE, head(tokens$type %in% c("comma", "operator"), -1))
  tokens$value[operator_newline] <- " "
  new_str <- paste(tokens$value, collapse = "")
  gsub("\\s*\\r?\\n\\s*", "\n", new_str)
}
format_tidy_code <- function(code_str) {
  code_str %>% rebreak() %>% style_text() %>% paste(collapse = "\n")
}
`knit_print.{` <- knit_print.call <- knit_print.name <-
  function(x, ...) {
    cat(format_tidy_code(x))
  }
```

## R Markdown

```{r cars}
library(shinymeta)

df <- metaReactive(iris)

first <- metaReactive(!!df() %>% head(1L))
last <- metaReactive(!!df() %>% tail(1L))

withMetaMode(rlang::expr({
  first <- !!first()
  last <- !!last()
}))


```
