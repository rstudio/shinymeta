% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metareactive.R
\name{expandCode}
\alias{expandCode}
\title{Expand meta primitives into user code}
\usage{
expandCode(expr, env = parent.frame(), quoted = FALSE,
  patchCalls = list())
}
\arguments{
\item{expr}{An expression (quoted or unquoted).}

\item{env}{An environment.}

\item{patchCalls}{a named list of quoted symbols. The names of the list
should match name(s) bound to relevant meta-component(s) found in \code{expr}
(e.g. \code{petal_width} in the example below). The quoted symbol(s) should
match variable name(s) representing the return value of the meta-component(s).}
}
\description{
This function provides the main entry point for generating user code
via meta-components (e.g., \code{\link[=metaReactive]{metaReactive()}}, \code{\link[=metaObserve]{metaObserve()}}, \code{\link[=metaRender]{metaRender()}}, etc).
It's similar to \code{\link[=withMetaMode]{withMetaMode()}}, but instead, quotes the \code{expr}, which allows you
to generate code from multiple meta-components via quasiquotation (e.g. \link[rlang:!!]{rlang::!!}).
When producing code from multiple meta-components, you may find that code produced from one
meta-component overlaps (i.e., repeats redundant computation) with another meta-component.
In that case, it's desirable to assign the return value of a meta-component to a variable, and
use that variable (i.e., symbol) in downstream code generated from other meta-components. This
can be done via the \code{patchCalls} argument which can replace the return value of
a meta-component with a relevant variable name.
}
\examples{

options(shiny.suppressMissingContextError = TRUE)

petal_width <- metaReactive({
  iris$Petal.Width
})

mean_pw <- metaReactive({
  mean(!!petal_width())
})

expandCode(
  {
    pw <- !!petal_width()
    !!mean_pw()
  },
  patchCalls = list(
    petal_width = quote(pw)
  )
)

}
\seealso{
\code{\link[=withMetaMode]{withMetaMode()}}
}
